// ==============================================================================
// Inventory Service API
// gRPC service for inventory management and reservation operations
// ==============================================================================

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: product/v1/inventory_service.proto

package productv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/daisuke8000/example-ec-platform/gen/product/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// InventoryServiceName is the fully-qualified name of the InventoryService service.
	InventoryServiceName = "product.v1.InventoryService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// InventoryServiceGetInventoryProcedure is the fully-qualified name of the InventoryService's
	// GetInventory RPC.
	InventoryServiceGetInventoryProcedure = "/product.v1.InventoryService/GetInventory"
	// InventoryServiceUpdateInventoryProcedure is the fully-qualified name of the InventoryService's
	// UpdateInventory RPC.
	InventoryServiceUpdateInventoryProcedure = "/product.v1.InventoryService/UpdateInventory"
	// InventoryServiceBatchReserveInventoryProcedure is the fully-qualified name of the
	// InventoryService's BatchReserveInventory RPC.
	InventoryServiceBatchReserveInventoryProcedure = "/product.v1.InventoryService/BatchReserveInventory"
	// InventoryServiceConfirmReservationProcedure is the fully-qualified name of the InventoryService's
	// ConfirmReservation RPC.
	InventoryServiceConfirmReservationProcedure = "/product.v1.InventoryService/ConfirmReservation"
	// InventoryServiceReleaseInventoryProcedure is the fully-qualified name of the InventoryService's
	// ReleaseInventory RPC.
	InventoryServiceReleaseInventoryProcedure = "/product.v1.InventoryService/ReleaseInventory"
	// InventoryServiceUpdateReservationProcedure is the fully-qualified name of the InventoryService's
	// UpdateReservation RPC.
	InventoryServiceUpdateReservationProcedure = "/product.v1.InventoryService/UpdateReservation"
	// InventoryServiceGetReservationStatusProcedure is the fully-qualified name of the
	// InventoryService's GetReservationStatus RPC.
	InventoryServiceGetReservationStatusProcedure = "/product.v1.InventoryService/GetReservationStatus"
)

// InventoryServiceClient is a client for the product.v1.InventoryService service.
type InventoryServiceClient interface {
	// GetInventory retrieves current stock levels for a SKU.
	// Returns NOT_FOUND if SKU doesn't exist.
	GetInventory(context.Context, *connect.Request[v1.GetInventoryRequest]) (*connect.Response[v1.GetInventoryResponse], error)
	// UpdateInventory modifies the stock quantity for a SKU.
	// Returns NOT_FOUND if SKU doesn't exist.
	// Returns ABORTED if version conflict (optimistic locking).
	// Returns INVALID_ARGUMENT if update would result in negative available quantity.
	// Returns PERMISSION_DENIED if caller lacks admin role.
	UpdateInventory(context.Context, *connect.Request[v1.UpdateInventoryRequest]) (*connect.Response[v1.UpdateInventoryResponse], error)
	// BatchReserveInventory atomically reserves inventory for multiple SKUs.
	// This is the "Try" phase of the TCC pattern.
	//
	// Behavior:
	// - All-or-Nothing: Either all items are reserved or none are
	// - Idempotent: Same idempotency_key returns same response
	// - TTL: Reservations expire after 15 minutes (configurable)
	//
	// Returns RESOURCE_EXHAUSTED with InsufficientStockDetail if any SKU lacks stock.
	// Returns INVALID_ARGUMENT if batch size exceeds limit (50 SKUs).
	BatchReserveInventory(context.Context, *connect.Request[v1.BatchReserveInventoryRequest]) (*connect.Response[v1.BatchReserveInventoryResponse], error)
	// ConfirmReservation permanently commits the reservation.
	// This is the "Confirm" phase of the TCC pattern.
	//
	// Behavior:
	// - Decrements actual inventory quantity
	// - Marks reservation as CONFIRMED
	// - Idempotent: Same idempotency_key returns same response
	//
	// Returns NOT_FOUND if reservation doesn't exist.
	// Returns ABORTED if reservation has expired (status: EXPIRED).
	// Returns FAILED_PRECONDITION if reservation is not in PENDING state.
	ConfirmReservation(context.Context, *connect.Request[v1.ConfirmReservationRequest]) (*connect.Response[v1.ConfirmReservationResponse], error)
	// ReleaseInventory cancels a reservation and returns stock.
	// This is the "Cancel" phase of the TCC pattern.
	//
	// Behavior:
	// - Returns reserved quantity to available stock
	// - Marks reservation as RELEASED
	// - Idempotent: Same idempotency_key returns same response
	//
	// Returns NOT_FOUND if reservation doesn't exist.
	// Returns FAILED_PRECONDITION if reservation is already CONFIRMED or EXPIRED.
	ReleaseInventory(context.Context, *connect.Request[v1.ReleaseInventoryRequest]) (*connect.Response[v1.ReleaseInventoryResponse], error)
	// UpdateReservation adjusts the quantity of an existing reservation.
	//
	// Behavior:
	// - Increase: Requires availability check
	// - Decrease: Always succeeds (releases partial quantity)
	//
	// Returns NOT_FOUND if reservation doesn't exist.
	// Returns RESOURCE_EXHAUSTED if increasing beyond available quantity.
	// Returns FAILED_PRECONDITION if reservation is not in PENDING state.
	UpdateReservation(context.Context, *connect.Request[v1.UpdateReservationRequest]) (*connect.Response[v1.UpdateReservationResponse], error)
	// GetReservationStatus retrieves the current state of a reservation.
	// Returns status NOT_FOUND (in response, not error) if reservation doesn't exist.
	GetReservationStatus(context.Context, *connect.Request[v1.GetReservationStatusRequest]) (*connect.Response[v1.GetReservationStatusResponse], error)
}

// NewInventoryServiceClient constructs a client for the product.v1.InventoryService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewInventoryServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) InventoryServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	inventoryServiceMethods := v1.File_product_v1_inventory_service_proto.Services().ByName("InventoryService").Methods()
	return &inventoryServiceClient{
		getInventory: connect.NewClient[v1.GetInventoryRequest, v1.GetInventoryResponse](
			httpClient,
			baseURL+InventoryServiceGetInventoryProcedure,
			connect.WithSchema(inventoryServiceMethods.ByName("GetInventory")),
			connect.WithClientOptions(opts...),
		),
		updateInventory: connect.NewClient[v1.UpdateInventoryRequest, v1.UpdateInventoryResponse](
			httpClient,
			baseURL+InventoryServiceUpdateInventoryProcedure,
			connect.WithSchema(inventoryServiceMethods.ByName("UpdateInventory")),
			connect.WithClientOptions(opts...),
		),
		batchReserveInventory: connect.NewClient[v1.BatchReserveInventoryRequest, v1.BatchReserveInventoryResponse](
			httpClient,
			baseURL+InventoryServiceBatchReserveInventoryProcedure,
			connect.WithSchema(inventoryServiceMethods.ByName("BatchReserveInventory")),
			connect.WithClientOptions(opts...),
		),
		confirmReservation: connect.NewClient[v1.ConfirmReservationRequest, v1.ConfirmReservationResponse](
			httpClient,
			baseURL+InventoryServiceConfirmReservationProcedure,
			connect.WithSchema(inventoryServiceMethods.ByName("ConfirmReservation")),
			connect.WithClientOptions(opts...),
		),
		releaseInventory: connect.NewClient[v1.ReleaseInventoryRequest, v1.ReleaseInventoryResponse](
			httpClient,
			baseURL+InventoryServiceReleaseInventoryProcedure,
			connect.WithSchema(inventoryServiceMethods.ByName("ReleaseInventory")),
			connect.WithClientOptions(opts...),
		),
		updateReservation: connect.NewClient[v1.UpdateReservationRequest, v1.UpdateReservationResponse](
			httpClient,
			baseURL+InventoryServiceUpdateReservationProcedure,
			connect.WithSchema(inventoryServiceMethods.ByName("UpdateReservation")),
			connect.WithClientOptions(opts...),
		),
		getReservationStatus: connect.NewClient[v1.GetReservationStatusRequest, v1.GetReservationStatusResponse](
			httpClient,
			baseURL+InventoryServiceGetReservationStatusProcedure,
			connect.WithSchema(inventoryServiceMethods.ByName("GetReservationStatus")),
			connect.WithClientOptions(opts...),
		),
	}
}

// inventoryServiceClient implements InventoryServiceClient.
type inventoryServiceClient struct {
	getInventory          *connect.Client[v1.GetInventoryRequest, v1.GetInventoryResponse]
	updateInventory       *connect.Client[v1.UpdateInventoryRequest, v1.UpdateInventoryResponse]
	batchReserveInventory *connect.Client[v1.BatchReserveInventoryRequest, v1.BatchReserveInventoryResponse]
	confirmReservation    *connect.Client[v1.ConfirmReservationRequest, v1.ConfirmReservationResponse]
	releaseInventory      *connect.Client[v1.ReleaseInventoryRequest, v1.ReleaseInventoryResponse]
	updateReservation     *connect.Client[v1.UpdateReservationRequest, v1.UpdateReservationResponse]
	getReservationStatus  *connect.Client[v1.GetReservationStatusRequest, v1.GetReservationStatusResponse]
}

// GetInventory calls product.v1.InventoryService.GetInventory.
func (c *inventoryServiceClient) GetInventory(ctx context.Context, req *connect.Request[v1.GetInventoryRequest]) (*connect.Response[v1.GetInventoryResponse], error) {
	return c.getInventory.CallUnary(ctx, req)
}

// UpdateInventory calls product.v1.InventoryService.UpdateInventory.
func (c *inventoryServiceClient) UpdateInventory(ctx context.Context, req *connect.Request[v1.UpdateInventoryRequest]) (*connect.Response[v1.UpdateInventoryResponse], error) {
	return c.updateInventory.CallUnary(ctx, req)
}

// BatchReserveInventory calls product.v1.InventoryService.BatchReserveInventory.
func (c *inventoryServiceClient) BatchReserveInventory(ctx context.Context, req *connect.Request[v1.BatchReserveInventoryRequest]) (*connect.Response[v1.BatchReserveInventoryResponse], error) {
	return c.batchReserveInventory.CallUnary(ctx, req)
}

// ConfirmReservation calls product.v1.InventoryService.ConfirmReservation.
func (c *inventoryServiceClient) ConfirmReservation(ctx context.Context, req *connect.Request[v1.ConfirmReservationRequest]) (*connect.Response[v1.ConfirmReservationResponse], error) {
	return c.confirmReservation.CallUnary(ctx, req)
}

// ReleaseInventory calls product.v1.InventoryService.ReleaseInventory.
func (c *inventoryServiceClient) ReleaseInventory(ctx context.Context, req *connect.Request[v1.ReleaseInventoryRequest]) (*connect.Response[v1.ReleaseInventoryResponse], error) {
	return c.releaseInventory.CallUnary(ctx, req)
}

// UpdateReservation calls product.v1.InventoryService.UpdateReservation.
func (c *inventoryServiceClient) UpdateReservation(ctx context.Context, req *connect.Request[v1.UpdateReservationRequest]) (*connect.Response[v1.UpdateReservationResponse], error) {
	return c.updateReservation.CallUnary(ctx, req)
}

// GetReservationStatus calls product.v1.InventoryService.GetReservationStatus.
func (c *inventoryServiceClient) GetReservationStatus(ctx context.Context, req *connect.Request[v1.GetReservationStatusRequest]) (*connect.Response[v1.GetReservationStatusResponse], error) {
	return c.getReservationStatus.CallUnary(ctx, req)
}

// InventoryServiceHandler is an implementation of the product.v1.InventoryService service.
type InventoryServiceHandler interface {
	// GetInventory retrieves current stock levels for a SKU.
	// Returns NOT_FOUND if SKU doesn't exist.
	GetInventory(context.Context, *connect.Request[v1.GetInventoryRequest]) (*connect.Response[v1.GetInventoryResponse], error)
	// UpdateInventory modifies the stock quantity for a SKU.
	// Returns NOT_FOUND if SKU doesn't exist.
	// Returns ABORTED if version conflict (optimistic locking).
	// Returns INVALID_ARGUMENT if update would result in negative available quantity.
	// Returns PERMISSION_DENIED if caller lacks admin role.
	UpdateInventory(context.Context, *connect.Request[v1.UpdateInventoryRequest]) (*connect.Response[v1.UpdateInventoryResponse], error)
	// BatchReserveInventory atomically reserves inventory for multiple SKUs.
	// This is the "Try" phase of the TCC pattern.
	//
	// Behavior:
	// - All-or-Nothing: Either all items are reserved or none are
	// - Idempotent: Same idempotency_key returns same response
	// - TTL: Reservations expire after 15 minutes (configurable)
	//
	// Returns RESOURCE_EXHAUSTED with InsufficientStockDetail if any SKU lacks stock.
	// Returns INVALID_ARGUMENT if batch size exceeds limit (50 SKUs).
	BatchReserveInventory(context.Context, *connect.Request[v1.BatchReserveInventoryRequest]) (*connect.Response[v1.BatchReserveInventoryResponse], error)
	// ConfirmReservation permanently commits the reservation.
	// This is the "Confirm" phase of the TCC pattern.
	//
	// Behavior:
	// - Decrements actual inventory quantity
	// - Marks reservation as CONFIRMED
	// - Idempotent: Same idempotency_key returns same response
	//
	// Returns NOT_FOUND if reservation doesn't exist.
	// Returns ABORTED if reservation has expired (status: EXPIRED).
	// Returns FAILED_PRECONDITION if reservation is not in PENDING state.
	ConfirmReservation(context.Context, *connect.Request[v1.ConfirmReservationRequest]) (*connect.Response[v1.ConfirmReservationResponse], error)
	// ReleaseInventory cancels a reservation and returns stock.
	// This is the "Cancel" phase of the TCC pattern.
	//
	// Behavior:
	// - Returns reserved quantity to available stock
	// - Marks reservation as RELEASED
	// - Idempotent: Same idempotency_key returns same response
	//
	// Returns NOT_FOUND if reservation doesn't exist.
	// Returns FAILED_PRECONDITION if reservation is already CONFIRMED or EXPIRED.
	ReleaseInventory(context.Context, *connect.Request[v1.ReleaseInventoryRequest]) (*connect.Response[v1.ReleaseInventoryResponse], error)
	// UpdateReservation adjusts the quantity of an existing reservation.
	//
	// Behavior:
	// - Increase: Requires availability check
	// - Decrease: Always succeeds (releases partial quantity)
	//
	// Returns NOT_FOUND if reservation doesn't exist.
	// Returns RESOURCE_EXHAUSTED if increasing beyond available quantity.
	// Returns FAILED_PRECONDITION if reservation is not in PENDING state.
	UpdateReservation(context.Context, *connect.Request[v1.UpdateReservationRequest]) (*connect.Response[v1.UpdateReservationResponse], error)
	// GetReservationStatus retrieves the current state of a reservation.
	// Returns status NOT_FOUND (in response, not error) if reservation doesn't exist.
	GetReservationStatus(context.Context, *connect.Request[v1.GetReservationStatusRequest]) (*connect.Response[v1.GetReservationStatusResponse], error)
}

// NewInventoryServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewInventoryServiceHandler(svc InventoryServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	inventoryServiceMethods := v1.File_product_v1_inventory_service_proto.Services().ByName("InventoryService").Methods()
	inventoryServiceGetInventoryHandler := connect.NewUnaryHandler(
		InventoryServiceGetInventoryProcedure,
		svc.GetInventory,
		connect.WithSchema(inventoryServiceMethods.ByName("GetInventory")),
		connect.WithHandlerOptions(opts...),
	)
	inventoryServiceUpdateInventoryHandler := connect.NewUnaryHandler(
		InventoryServiceUpdateInventoryProcedure,
		svc.UpdateInventory,
		connect.WithSchema(inventoryServiceMethods.ByName("UpdateInventory")),
		connect.WithHandlerOptions(opts...),
	)
	inventoryServiceBatchReserveInventoryHandler := connect.NewUnaryHandler(
		InventoryServiceBatchReserveInventoryProcedure,
		svc.BatchReserveInventory,
		connect.WithSchema(inventoryServiceMethods.ByName("BatchReserveInventory")),
		connect.WithHandlerOptions(opts...),
	)
	inventoryServiceConfirmReservationHandler := connect.NewUnaryHandler(
		InventoryServiceConfirmReservationProcedure,
		svc.ConfirmReservation,
		connect.WithSchema(inventoryServiceMethods.ByName("ConfirmReservation")),
		connect.WithHandlerOptions(opts...),
	)
	inventoryServiceReleaseInventoryHandler := connect.NewUnaryHandler(
		InventoryServiceReleaseInventoryProcedure,
		svc.ReleaseInventory,
		connect.WithSchema(inventoryServiceMethods.ByName("ReleaseInventory")),
		connect.WithHandlerOptions(opts...),
	)
	inventoryServiceUpdateReservationHandler := connect.NewUnaryHandler(
		InventoryServiceUpdateReservationProcedure,
		svc.UpdateReservation,
		connect.WithSchema(inventoryServiceMethods.ByName("UpdateReservation")),
		connect.WithHandlerOptions(opts...),
	)
	inventoryServiceGetReservationStatusHandler := connect.NewUnaryHandler(
		InventoryServiceGetReservationStatusProcedure,
		svc.GetReservationStatus,
		connect.WithSchema(inventoryServiceMethods.ByName("GetReservationStatus")),
		connect.WithHandlerOptions(opts...),
	)
	return "/product.v1.InventoryService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case InventoryServiceGetInventoryProcedure:
			inventoryServiceGetInventoryHandler.ServeHTTP(w, r)
		case InventoryServiceUpdateInventoryProcedure:
			inventoryServiceUpdateInventoryHandler.ServeHTTP(w, r)
		case InventoryServiceBatchReserveInventoryProcedure:
			inventoryServiceBatchReserveInventoryHandler.ServeHTTP(w, r)
		case InventoryServiceConfirmReservationProcedure:
			inventoryServiceConfirmReservationHandler.ServeHTTP(w, r)
		case InventoryServiceReleaseInventoryProcedure:
			inventoryServiceReleaseInventoryHandler.ServeHTTP(w, r)
		case InventoryServiceUpdateReservationProcedure:
			inventoryServiceUpdateReservationHandler.ServeHTTP(w, r)
		case InventoryServiceGetReservationStatusProcedure:
			inventoryServiceGetReservationStatusHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedInventoryServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedInventoryServiceHandler struct{}

func (UnimplementedInventoryServiceHandler) GetInventory(context.Context, *connect.Request[v1.GetInventoryRequest]) (*connect.Response[v1.GetInventoryResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("product.v1.InventoryService.GetInventory is not implemented"))
}

func (UnimplementedInventoryServiceHandler) UpdateInventory(context.Context, *connect.Request[v1.UpdateInventoryRequest]) (*connect.Response[v1.UpdateInventoryResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("product.v1.InventoryService.UpdateInventory is not implemented"))
}

func (UnimplementedInventoryServiceHandler) BatchReserveInventory(context.Context, *connect.Request[v1.BatchReserveInventoryRequest]) (*connect.Response[v1.BatchReserveInventoryResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("product.v1.InventoryService.BatchReserveInventory is not implemented"))
}

func (UnimplementedInventoryServiceHandler) ConfirmReservation(context.Context, *connect.Request[v1.ConfirmReservationRequest]) (*connect.Response[v1.ConfirmReservationResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("product.v1.InventoryService.ConfirmReservation is not implemented"))
}

func (UnimplementedInventoryServiceHandler) ReleaseInventory(context.Context, *connect.Request[v1.ReleaseInventoryRequest]) (*connect.Response[v1.ReleaseInventoryResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("product.v1.InventoryService.ReleaseInventory is not implemented"))
}

func (UnimplementedInventoryServiceHandler) UpdateReservation(context.Context, *connect.Request[v1.UpdateReservationRequest]) (*connect.Response[v1.UpdateReservationResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("product.v1.InventoryService.UpdateReservation is not implemented"))
}

func (UnimplementedInventoryServiceHandler) GetReservationStatus(context.Context, *connect.Request[v1.GetReservationStatusRequest]) (*connect.Response[v1.GetReservationStatusResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("product.v1.InventoryService.GetReservationStatus is not implemented"))
}
